[[c_transactions]]
== Transazioni

Il modo in cui trasferiamo denaro contante è molto diverso da come trasferiamo bitcoin. Il denaro contante è un token al portatore: Alice paga Bob consegnandogli fisicamente un certo numero di token, come delle banconote.
A differenza del contante, i bitcoin non esistono né in forma fisica né come dati digitali: Alice non può consegnare materialmente dei bitcoin a Bob o inviarglieli via email.

Consideriamo invece come Alice potrebbe trasferire a Bob la proprietà di un appezzamento di terreno. Non può fisicamente sollevare il terreno e consegnarlo a Bob. Esiste invece un registro (solitamente tenuto da un ente governativo locale) che descrive il terreno di proprietà di Alice. Alice trasferisce quel terreno a Bob convincendo l'ente responsabile ad aggiornare il registro per attestare che Bob è ora il nuovo proprietario.

Bitcoin funziona in modo analogo. Su ogni nodo completo Bitcoin esiste un database che indica che Alice controlla un certo numero di bitcoin. Alice paga Bob convincendo i nodi completi ad aggiornare il proprio database, indicando che alcuni dei bitcoin di Alice sono ora sotto il controllo di Bob. I dati che Alice utilizza per convincere i nodi completi ad aggiornare i loro database costituiscono una _transazione_. Questo processo avviene senza utilizzare direttamente le identità di Alice o Bob, come vedremo in <<c_authorization_authentication>>.

In questo capitolo analizzeremo nel dettaglio una transazione Bitcoin ed esamineremo ciascuna delle sue componenti per capire come permettono il trasferimento di valore in modo estremamente versatile e incredibilmente affidabile.

[[tx_structure]]
=== Una Transazione Bitcoin Serializzata

In <<exploring_and_decoding_transactions>>, abbiamo utilizzato Bitcoin Core con l'opzione `txindex` abilitata per recuperare una copia del pagamento di Alice a Bob. Recuperiamo ancora una volta la transazione che contiene quel pagamento, come mostrato in <<alice_tx_serialized_reprint>>.

[[alice_tx_serialized_reprint]]
.Alice's serialized transaction
====
----
$ bitcoin-cli getrawtransaction 466200308696215bbc949d5141a49a41\
38ecdfdfaa2a8029c1f9bcecd1f96177

01000000000101eb3ae38f27191aa5f3850dc9cad00492b88b72404f9da13569
8679268041c54a0100000000ffffffff02204e0000000000002251203b41daba
4c9ace578369740f15e5ec880c28279ee7f51b07dca69c7061e07068f8240100
000000001600147752c165ea7be772b2c0acb7f4d6047ae6f4768e0141cf5efe
2d8ef13ed0af21d4f4cb82422d6252d70324f6f4576b727b7d918e521c00b51b
e739df2f899c49dc267c0ad280aca6dab0d2fa2b42a45182fc83e81713010000
0000
----
====


Il formato di serializzazione di Bitcoin Core è speciale perché è il formato usato per per generare impegni crittografici sulle transazioni e per trasmetterle attraverso la rete P2P di Bitcoin. In altri contesti, tuttavia, i programmi possono usare un formato diverso, purché trasmettano tutti gli stessi dati. Il formato di Bitcoin Core, però, è ragionevolmente compatto per i dati che trasmette e semplice da decodificare, quindi molti altri programmi Bitcoin utilizzano questo formato.

[TIP]
====
L’unico altro formato di serializzazione delle transazioni largamente utilizzato di cui siamo a conoscenza è il formato Partially Signed Bitcoin Transaction (PSBT), documentato nei BIP 174 e 370 (con estensioni descritte in altri BIP). Il formato PSBT consente a un programma non fidato di creare un modello di transazione che può essere verificato e completato da programmi fidati (come i dispositivi hardware di firma) che possiedono le chiavi private necessarie o altri dati sensibili per compilare il modello. A tal fine, PSBT permette di memorizzare una quantità significativa di metadati relativi a una transazione, rendendolo molto meno compatto rispetto al formato di serializzazione standard. Questo libro non entra nei dettagli del PSBT, ma lo raccomandiamo fortemente agli sviluppatori di wallet che prevedono di supportare la firma multi-chiave.
====




La transazione mostrata in formato esadecimale in <<alice_tx_serialized_reprint>> è riprodotta come mappa di byte in <<alice_tx_byte_map>>. Si noti che sono necessari 64 caratteri esadecimali per visualizzare 32 byte. Questa mappa illustra solo i campi di primo livello. Esamineremo ciascuno di essi nell'ordine in cui compaiono nella transazione, descrivendo anche eventuali campi aggiuntivi in essi contenuti.

[[alice_tx_byte_map]]
.Una mappa di byte della transazione di Alice.
image::images/mbc3_0601.png["Una mappa di byte della transazione di Alice"]

[[version]]
=== Versione

I primi quattro byte di una transazione Bitcoin serializzata ne indicano la versione. La versione originale delle transazioni Bitcoin era la versione 1 (0x01000000). Tutte le transazioni Bitcoin devono rispettare le regole definite per la versione 1, molte delle quali sono descritte nel corso di questo libro.

La versione 2 delle transazioni Bitcoin è stata introdotta con il soft fork definito nel BIP68, che ha modificato le regole di consenso di Bitcoin. Il BIP68 impone vincoli aggiuntivi sul campo `sequence`, ma tali vincoli si applicano esclusivamente alle transazioni di versione 2 o superiore. Le transazioni di versione 1 non sono influenzate da questa modifica. Il BIP112, introdotto con lo stesso soft fork del BIP68, ha aggiornato l'opcode `++OP_CHECKSEQUENCEVERIFY++`, il quale ora fallirà se valutato all'interno di una transazione con versione inferiore a 2. A parte queste due modifiche, le transazioni di versione 2 sono identiche a quelle di versione 1.

[role="less_space pagebreak-before"]
.Proteggere le Transazioni Pre-firmate
****
L'ultimo passaggio prima di diffondere una transazione sulla rete affinché venga inclusa nella blockchain consiste nel firmarla. Tuttavia, è possibile firmare una transazione senza diffonderla immediatamente. È possibile salvare tale transazione pre-firmata per mesi o anni, confidando che possa essere aggiunta alla blockchain in un secondo momento, quando verrà diffusa. Nel frattempo, si potrebbe persino perdere l'accesso alla chiave privata (o alle chiavi) necessaria per firmare una transazione alternativa che spenda gli stessi fondi. Non si tratta di un'ipotesi: diversi protocolli basati su Bitcoin, tra cui il Lightning Network, dipendono da [.keep-together]#transazioni# pre-firmate.

Ciò rappresenta una sfida per gli sviluppatori di protocolli quando supportano gli utenti nell'aggiornamento del protocollo di consenso di Bitcoin. L'introduzione di nuovi vincoli – come quelli aggiunti dal BIP68 al campo `sequence` – potrebbe invalidare alcune transazioni pre-firmate. Se non esiste un modo per creare una nuova firma per una transazione equivalente, i fondi che sarebbero stati spesi tramite la transazione pre-firmata andranno persi definitivamente.

Questo problema viene risolto riservando alcune funzionalità delle transazioni, come i numeri di versione, per futuri aggiornamenti. Chiunque avesse creato transazioni pre-firmate prima dell'introduzione del BIP68 avrebbe dovuto utilizzare la versione 1. Pertanto, applicando i vincoli aggiuntivi del BIP68 sul campo `sequence` solo alle transazioni di versione 2 o superiore, non si dovrebbero invalidare le [.keep-together]#transazioni# pre-firmate esistenti.

Se si implementa un protocollo che utilizza transazioni pre-firmate, è necessario assicurarsi che non impieghi funzionalità riservate a futuri aggiornamenti. La policy di default di Bitcoin Core per l'inoltro (relay) delle transazioni non permette l'uso di funzionalità riservate. È possibile verificare la conformità di una transazione a tale policy utilizzando la chiamata RPC `+testmempoolaccept+` di Bitcoin Core sulla mainnet di Bitcoin.
****

Al momento della stesura di questo testo, è in fase di ampia discussione una proposta per iniziare a utilizzare le transazioni di versione 3. Tale proposta non mira a modificare le regole di consenso, ma soltanto la policy utilizzata dai nodi completi Bitcoin per l'inoltro (relay) delle transazioni. Secondo questa proposta, le transazioni di versione 3 sarebbero soggette a vincoli aggiuntivi volti a prevenire determinati attacchi di tipo Denial of Service (DoS), che approfondiremo nella sezione <<transaction_pinning>>.

=== Marker e Flag (Formato Esteso)

I due campi successivi ((("transactions", "extended serialization format")))((("extended serialization format")))((("BIP144 extended serialization format"))) della transazione serializzata d'esempio sono stati aggiunti nell'ambito del soft fork Segregated Witness (SegWit), che ha modificato le regole di consenso di Bitcoin. Le regole sono state modificate conformemente ai BIP 141 e 143, ma il _formato di serializzazione esteso_ è definito nel BIP144.

[role="less_space pagebreak-before"]
Se la transazione include una struttura dati witness (descritta in <<witness_structure>>), il campo marker deve essere zero (0x00) e il campo flag deve essere non-zero. Nell'attuale protocollo P2P, il flag dovrebbe sempre valere uno (0x01); valori alternativi per il flag sono riservati a futuri aggiornamenti del protocollo.

Se la transazione non necessita di uno stack witness, i campi marker e flag non devono essere presenti. Ciò garantisce la compatibilità con il formato di serializzazione originale delle transazioni Bitcoin, ora denominato _serializzazione legacy_. Per i dettagli, si veda <<legacy_serialization>>.

Nella ((("transactions", "legacy serialization")))((("legacy serialization")))serializzazione legacy, il byte del marker sarebbe stato interpretato come il numero di input (zero). Poiché una transazione non può avere zero input, il marker segnala ai software moderni che è in uso il formato di serializzazione esteso. Il campo flag fornisce un'indicazione analoga e, inoltre, semplifica eventuali futuri aggiornamenti del formato di serializzazione.

[[inputs]]
=== Input

Il campo degli input ((("transactions", "inputs", id="transaction-input")))((("inputs", id="input-transaction"))) contiene diversi sotto-campi; iniziamo quindi mostrando una mappa dei byte corrispondenti in <<alice_tx_input_map>>.

[[alice_tx_input_map]]
.Mappa dei byte nel campo degli input della transazione di Alice.
image::images/mbc3_0602.png["mappa dei byte nel campo input della transazione di Alice"]

==== Numero di Input della Transazione

La sezione degli input ((("transactions", "inputs", "length of list", id="transaction-input-length")))((("inputs", "length of list", id="input-transaction-length"))) della transazione inizia con un intero che specifica il numero di input contenuti nella transazione stessa. Il valore minimo è uno. Non esiste un limite massimo esplicito, ma le restrizioni sulla dimensione complessiva di una transazione limitano di fatto il numero di input a qualche migliaio. Questo numero è codificato come intero senza segno nel formato compactSize.

[role="less_space pagebreak-before"]
.Interi Senza Segno CompactSize
****
Gli interi senza segno ((("compactSize  unsigned integers", id="compactsize")))((("unsigned integers", id="unsigned"))) in Bitcoin, che spesso assumono valori bassi ma talvolta possono raggiungere valori elevati, sono solitamente codificati utilizzando il tipo di dato compactSize. Il formato compactSize è una variante di intero a lunghezza variabile, motivo per cui viene talvolta chiamato var_int o varint (si veda, ad esempio, la documentazione dei BIP 37 e 144).

[WARNING]
====
Esistono diverse varianti di interi a lunghezza variabile utilizzate in software differenti, inclusi diversi programmi dell'ecosistema Bitcoin. Ad esempio, Bitcoin Core serializza il proprio database UTXO utilizzando un tipo di dato denominato `+VarInts+`, che differisce dal formato compactSize. Inoltre, il campo `nBits` nell'header dei blocchi Bitcoin è codificato mediante un tipo di dato personalizzato noto come `+Compact+`, il quale non ha relazione con il formato compactSize. Quando ci riferiamo agli interi a lunghezza variabile impiegati nella serializzazione delle transazioni Bitcoin e in altre componenti del protocollo P2P di Bitcoin, utilizzeremo sempre la dicitura completa compactSize.
====

Per i numeri da 0 a 252, gli interi senza segno compactSize coincidono con il tipo di dato `uint8_t` del linguaggio C, che rappresenta verosimilmente la codifica nativa familiare alla maggior parte dei programmatori. Per numeri superiori, fino a `0xffffffffffffffff`, un byte viene anteposto al numero per indicarne la lunghezza; per il resto, i numeri seguono la normale codifica degli interi senza segno del linguaggio C:

++++
<table>
<thead>
<tr>
<th>Valore</th>
<th>Byte utilizzati</th>
<th>Formato</th>
</tr>
</thead>
<tbody>
<tr>
<td><p>≥ <code>0</code> &amp;&amp; ≤ <code>252</code> (<code>0xfc</code>)</p></td>
<td><p><code>1</code></p></td>
<td><p><code>uint8_t</code></p></td>
</tr>
<tr>
<td><p>≥ <code>253</code> &amp;&amp; ≤ <code>0xffff</code></p></td>
<td><p>3</p></td>
<td><p><code>0xfd</code> seguito dal numero come <code>uint16_t</code></p></td>
</tr>
<tr>
<td><p>≥ <code>0x10000</code> &amp;&amp; ≤ <code>0xffffffff</code></p></td>
<td><p><code>5</code></p></td>
<td><p><code>0xfe</code> seguito dal numero come <code>uint32_t</code></p></td>
</tr>
<tr>
<td><p>≥ <code>0x100000000</code> &amp;&amp; ≤ <code>0xffffffffffffffff</code></p></td>
<td><p><code>9</code></p></td>
<td><p><code>0xff</code> seguito dal numero come <code>uint64_t</code></p></td>
</tr>
</tbody>
</table>
++++
****

Ogni input di una transazione deve contenere tre campi: un campo _outpoint_, un campo _script di input_ (preceduto dalla sua lunghezza) e un campo _sequence_. Esamineremo ciascuno di questi campi nelle sezioni seguenti. Alcuni input includono anche uno stack witness; tuttavia, essendo questo serializzato alla fine della transazione, lo ((("transactions", "inputs", "length of list", startref="transaction-input-length")))((("inputs", "length of list", startref="input-transaction-length")))esamineremo in seguito.

[[outpoints]]
==== Outpoint

Una transazione Bitcoin ((("transactions", "inputs", "outpoint field", id="transaction-input-outpoint")))((("inputs", "outpoint field", id="input-transaction-outpoint")))((("outpoint field (transaction inputs)", id="outpoint"))) rappresenta una richiesta inviata ai nodi completi affinché aggiornino il proprio database contenente le informazioni sulla proprietà dei bitcoin. Affinché Alice possa trasferire a Bob il controllo di alcuni dei suoi bitcoin, deve prima indicare ai nodi completi come individuare la transazione precedente tramite la quale ha ricevuto tali bitcoin. Poiché il controllo sui bitcoin è assegnato negli output delle transazioni, Alice _punta_ all'_output_ precedente utilizzando un campo denominato _outpoint_. Ogni input deve contenere un singolo outpoint.

L'outpoint contiene il TXID (Transaction ID) di 32 byte della transazione tramite la quale Alice ha ricevuto i bitcoin che ora intende spendere. Questo TXID è rappresentato secondo l'ordine dei byte interno di Bitcoin per gli hash (si veda <<internal_and_display_order>>).

Poiché una transazione può contenere molteplici output, Alice deve anche specificare quale particolare output di quella transazione intende utilizzare, indicandone il relativo _indice di output_ ((("output indexes"))). Gli indici di output sono interi senza segno di 4 byte a partire da zero.

Quando un nodo completo elabora un outpoint, utilizza le informazioni in esso contenute per tentare di individuare l'output a cui fa riferimento. I nodi completi devono cercare tale output solo nelle transazioni precedenti presenti nella blockchain. Ad esempio, la transazione di Alice è inclusa nel blocco 774.958. Un nodo completo che sta verificando la transazione di Alice cercherà l'output precedente, referenziato dall'outpoint, esclusivamente in quel blocco (774.958) e nei blocchi che lo precedono, mai nei blocchi successivi. All'interno dello stesso blocco 774.958, il nodo prenderà in considerazione solo le transazioni che precedono quella di Alice nell'ordine definito dalle foglie dell'albero di Merkle del blocco (si veda <<merkle_trees>>).

Una volta individuato l'output precedente, il nodo completo ne estrae diverse informazioni cruciali:

*   L'ammontare di bitcoin assegnato a quell'output precedente. L'intera somma verrà trasferita con questa transazione. Nella transazione d'esempio, il valore dell'output precedente era di 100.000 satoshi.

*   Le condizioni di autorizzazione associate a quell'output precedente. Si tratta delle condizioni che devono essere soddisfatte per poter spendere i bitcoin assegnati a tale output.

*   Per le transazioni confermate: l'altezza del blocco che le ha confermate e il Median Time Past (MTP) di quel blocco. Queste informazioni sono necessarie per i timelock relativi (descritti in <<relative_timelocks>>) e per gli output delle transazioni coinbase (descritti in <<coinbase_transactions>>).

*   La prova che l'output precedente esista nella blockchain (o sia noto come transazione non confermata) e che nessun'altra transazione lo abbia già speso. Una delle regole di consenso di Bitcoin, infatti, proibisce che un output venga speso più di una volta all'interno di una blockchain valida.

