[[c_transactions]]
== Transazioni

Il modo in cui trasferiamo denaro contante è molto diverso da come trasferiamo bitcoin. Il denaro contante è un token al portatore: Alice paga Bob consegnandogli fisicamente un certo numero di token, come delle banconote.
A differenza del contante, i bitcoin non esistono né in forma fisica né come dati digitali: Alice non può consegnare materialmente dei bitcoin a Bob o inviarglieli via email.

Consideriamo invece come Alice potrebbe trasferire a Bob la proprietà di un appezzamento di terreno. Non può fisicamente sollevare il terreno e consegnarlo a Bob. Esiste invece un registro (solitamente tenuto da un ente governativo locale) che descrive il terreno di proprietà di Alice. Alice trasferisce quel terreno a Bob convincendo l'ente responsabile ad aggiornare il registro per attestare che Bob è ora il nuovo proprietario.

Bitcoin funziona in modo analogo. Su ogni nodo completo Bitcoin esiste un database che indica che Alice controlla un certo numero di bitcoin. Alice paga Bob convincendo i nodi completi ad aggiornare il proprio database, indicando che alcuni dei bitcoin di Alice sono ora sotto il controllo di Bob. I dati che Alice utilizza per convincere i nodi completi ad aggiornare i loro database costituiscono una _transazione_. Questo processo avviene senza utilizzare direttamente le identità di Alice o Bob, come vedremo in <<c_authorization_authentication>>.

In questo capitolo analizzeremo nel dettaglio una transazione Bitcoin ed esamineremo ciascuna delle sue componenti per capire come permettono il trasferimento di valore in modo estremamente versatile e incredibilmente affidabile.

[[tx_structure]]
=== Una Transazione Bitcoin Serializzata

In <<exploring_and_decoding_transactions>>, abbiamo utilizzato Bitcoin Core con l'opzione `txindex` abilitata per recuperare una copia del pagamento di Alice a Bob. Recuperiamo ancora una volta la transazione che contiene quel pagamento, come mostrato in <<alice_tx_serialized_reprint>>.

[[alice_tx_serialized_reprint]]
.Alice's serialized transaction
====
----
$ bitcoin-cli getrawtransaction 466200308696215bbc949d5141a49a41\
38ecdfdfaa2a8029c1f9bcecd1f96177

01000000000101eb3ae38f27191aa5f3850dc9cad00492b88b72404f9da13569
8679268041c54a0100000000ffffffff02204e0000000000002251203b41daba
4c9ace578369740f15e5ec880c28279ee7f51b07dca69c7061e07068f8240100
000000001600147752c165ea7be772b2c0acb7f4d6047ae6f4768e0141cf5efe
2d8ef13ed0af21d4f4cb82422d6252d70324f6f4576b727b7d918e521c00b51b
e739df2f899c49dc267c0ad280aca6dab0d2fa2b42a45182fc83e81713010000
0000
----
====


Il formato di serializzazione di Bitcoin Core è speciale perché è il formato usato per per generare impegni crittografici sulle transazioni e per trasmetterle attraverso la rete P2P di Bitcoin. In altri contesti, tuttavia, i programmi possono usare un formato diverso, purché trasmettano tutti gli stessi dati. Il formato di Bitcoin Core, però, è ragionevolmente compatto per i dati che trasmette e semplice da decodificare, quindi molti altri programmi Bitcoin utilizzano questo formato.

[TIP]
====
L’unico altro formato di serializzazione delle transazioni largamente utilizzato di cui siamo a conoscenza è il formato Partially Signed Bitcoin Transaction (PSBT), documentato nei BIP 174 e 370 (con estensioni descritte in altri BIP). Il formato PSBT consente a un programma non fidato di creare un modello di transazione che può essere verificato e completato da programmi fidati (come i dispositivi hardware di firma) che possiedono le chiavi private necessarie o altri dati sensibili per compilare il modello. A tal fine, PSBT permette di memorizzare una quantità significativa di metadati relativi a una transazione, rendendolo molto meno compatto rispetto al formato di serializzazione standard. Questo libro non entra nei dettagli del PSBT, ma lo raccomandiamo fortemente agli sviluppatori di wallet che prevedono di supportare la firma multi-chiave.
====




La transazione mostrata in formato esadecimale in <<alice_tx_serialized_reprint>> è riprodotta come mappa di byte in <<alice_tx_byte_map>>. Si noti che sono necessari 64 caratteri esadecimali per visualizzare 32 byte. Questa mappa illustra solo i campi di primo livello. Esamineremo ciascuno di essi nell'ordine in cui compaiono nella transazione, descrivendo anche eventuali campi aggiuntivi in essi contenuti.

[[alice_tx_byte_map]]
.Una mappa di byte della transazione di Alice.
image::images/mbc3_0601.png["Una mappa di byte della transazione di Alice"]

[[version]]
=== Versione

I primi quattro byte di una transazione Bitcoin serializzata ne indicano la versione. La versione originale delle transazioni Bitcoin era la versione 1 (0x01000000). Tutte le transazioni Bitcoin devono rispettare le regole definite per la versione 1, molte delle quali sono descritte nel corso di questo libro.

La versione 2 delle transazioni Bitcoin è stata introdotta con il soft fork definito nel BIP68, che ha modificato le regole di consenso di Bitcoin. Il BIP68 impone vincoli aggiuntivi sul campo `sequence`, ma tali vincoli si applicano esclusivamente alle transazioni di versione 2 o superiore. Le transazioni di versione 1 non sono influenzate da questa modifica. Il BIP112, introdotto con lo stesso soft fork del BIP68, ha aggiornato l'opcode `++OP_CHECKSEQUENCEVERIFY++`, il quale ora fallirà se valutato all'interno di una transazione con versione inferiore a 2. A parte queste due modifiche, le transazioni di versione 2 sono identiche a quelle di versione 1.

[role="less_space pagebreak-before"]
.Proteggere le Transazioni Pre-firmate
****
L'ultimo passaggio prima di diffondere una transazione sulla rete affinché venga inclusa nella blockchain consiste nel firmarla. Tuttavia, è possibile firmare una transazione senza diffonderla immediatamente. È possibile salvare tale transazione pre-firmata per mesi o anni, confidando che possa essere aggiunta alla blockchain in un secondo momento, quando verrà diffusa. Nel frattempo, si potrebbe persino perdere l'accesso alla chiave privata (o alle chiavi) necessaria per firmare una transazione alternativa che spenda gli stessi fondi. Non si tratta di un'ipotesi: diversi protocolli basati su Bitcoin, tra cui il Lightning Network, dipendono da [.keep-together]#transazioni# pre-firmate.

Ciò rappresenta una sfida per gli sviluppatori di protocolli quando supportano gli utenti nell'aggiornamento del protocollo di consenso di Bitcoin. L'introduzione di nuovi vincoli – come quelli aggiunti dal BIP68 al campo `sequence` – potrebbe invalidare alcune transazioni pre-firmate. Se non esiste un modo per creare una nuova firma per una transazione equivalente, i fondi che sarebbero stati spesi tramite la transazione pre-firmata andranno persi definitivamente.

Questo problema viene risolto riservando alcune funzionalità delle transazioni, come i numeri di versione, per futuri aggiornamenti. Chiunque avesse creato transazioni pre-firmate prima dell'introduzione del BIP68 avrebbe dovuto utilizzare la versione 1. Pertanto, applicando i vincoli aggiuntivi del BIP68 sul campo `sequence` solo alle transazioni di versione 2 o superiore, non si dovrebbero invalidare le [.keep-together]#transazioni# pre-firmate esistenti.

Se si implementa un protocollo che utilizza transazioni pre-firmate, è necessario assicurarsi che non impieghi funzionalità riservate a futuri aggiornamenti. La policy di default di Bitcoin Core per l'inoltro (relay) delle transazioni non permette l'uso di funzionalità riservate. È possibile verificare la conformità di una transazione a tale policy utilizzando la chiamata RPC `+testmempoolaccept+` di Bitcoin Core sulla mainnet di Bitcoin.
****

Al momento della stesura di questo testo, è in fase di ampia discussione una proposta per iniziare a utilizzare le transazioni di versione 3. Tale proposta non mira a modificare le regole di consenso, ma soltanto la policy utilizzata dai nodi completi Bitcoin per l'inoltro (relay) delle transazioni. Secondo questa proposta, le transazioni di versione 3 sarebbero soggette a vincoli aggiuntivi volti a prevenire determinati attacchi di tipo Denial of Service (DoS), che approfondiremo nella sezione <<transaction_pinning>>.

=== Marker e Flag (Formato Esteso)

I due campi successivi ((("transactions", "extended serialization format")))((("extended serialization format")))((("BIP144 extended serialization format"))) della transazione serializzata d'esempio sono stati aggiunti nell'ambito del soft fork Segregated Witness (SegWit), che ha modificato le regole di consenso di Bitcoin. Le regole sono state modificate conformemente ai BIP 141 e 143, ma il _formato di serializzazione esteso_ è definito nel BIP144.

[role="less_space pagebreak-before"]
Se la transazione include una struttura dati witness (descritta in <<witness_structure>>), il campo marker deve essere zero (0x00) e il campo flag deve essere non-zero. Nell'attuale protocollo P2P, il flag dovrebbe sempre valere uno (0x01); valori alternativi per il flag sono riservati a futuri aggiornamenti del protocollo.

Se la transazione non necessita di uno stack witness, i campi marker e flag non devono essere presenti. Ciò garantisce la compatibilità con il formato di serializzazione originale delle transazioni Bitcoin, ora denominato _serializzazione legacy_. Per i dettagli, si veda <<legacy_serialization>>.

Nella ((("transactions", "legacy serialization")))((("legacy serialization")))serializzazione legacy, il byte del marker sarebbe stato interpretato come il numero di input (zero). Poiché una transazione non può avere zero input, il marker segnala ai software moderni che è in uso il formato di serializzazione esteso. Il campo flag fornisce un'indicazione analoga e, inoltre, semplifica eventuali futuri aggiornamenti del formato di serializzazione.

[[inputs]]
=== Input

Il campo degli input ((("transactions", "inputs", id="transaction-input")))((("inputs", id="input-transaction"))) contiene diversi sotto-campi; iniziamo quindi mostrando una mappa dei byte corrispondenti in <<alice_tx_input_map>>.

[[alice_tx_input_map]]
.Mappa dei byte nel campo degli input della transazione di Alice.
image::images/mbc3_0602.png["mappa dei byte nel campo input della transazione di Alice"]

==== Numero di Input della Transazione

La sezione degli input ((("transactions", "inputs", "length of list", id="transaction-input-length")))((("inputs", "length of list", id="input-transaction-length"))) della transazione inizia con un intero che specifica il numero di input contenuti nella transazione stessa. Il valore minimo è uno. Non esiste un limite massimo esplicito, ma le restrizioni sulla dimensione complessiva di una transazione limitano di fatto il numero di input a qualche migliaio. Questo numero è codificato come intero senza segno nel formato compactSize.

[role="less_space pagebreak-before"]
.Interi Senza Segno CompactSize
****
Gli interi senza segno ((("compactSize  unsigned integers", id="compactsize")))((("unsigned integers", id="unsigned"))) in Bitcoin, che spesso assumono valori bassi ma talvolta possono raggiungere valori elevati, sono solitamente codificati utilizzando il tipo di dato compactSize. Il formato compactSize è una variante di intero a lunghezza variabile, motivo per cui viene talvolta chiamato var_int o varint (si veda, ad esempio, la documentazione dei BIP 37 e 144).

[WARNING]
====
Esistono diverse varianti di interi a lunghezza variabile utilizzate in software differenti, inclusi diversi programmi dell'ecosistema Bitcoin. Ad esempio, Bitcoin Core serializza il proprio database UTXO utilizzando un tipo di dato denominato `+VarInts+`, che differisce dal formato compactSize. Inoltre, il campo `nBits` nell'header dei blocchi Bitcoin è codificato mediante un tipo di dato personalizzato noto come `+Compact+`, il quale non ha relazione con il formato compactSize. Quando ci riferiamo agli interi a lunghezza variabile impiegati nella serializzazione delle transazioni Bitcoin e in altre componenti del protocollo P2P di Bitcoin, utilizzeremo sempre la dicitura completa compactSize.
====

Per i numeri da 0 a 252, gli interi senza segno compactSize coincidono con il tipo di dato `uint8_t` del linguaggio C, che rappresenta verosimilmente la codifica nativa familiare alla maggior parte dei programmatori. Per numeri superiori, fino a `0xffffffffffffffff`, un byte viene anteposto al numero per indicarne la lunghezza; per il resto, i numeri seguono la normale codifica degli interi senza segno del linguaggio C:

++++
<table>
<thead>
<tr>
<th>Valore</th>
<th>Byte utilizzati</th>
<th>Formato</th>
</tr>
</thead>
<tbody>
<tr>
<td><p>≥ <code>0</code> &amp;&amp; ≤ <code>252</code> (<code>0xfc</code>)</p></td>
<td><p><code>1</code></p></td>
<td><p><code>uint8_t</code></p></td>
</tr>
<tr>
<td><p>≥ <code>253</code> &amp;&amp; ≤ <code>0xffff</code></p></td>
<td><p>3</p></td>
<td><p><code>0xfd</code> seguito dal numero come <code>uint16_t</code></p></td>
</tr>
<tr>
<td><p>≥ <code>0x10000</code> &amp;&amp; ≤ <code>0xffffffff</code></p></td>
<td><p><code>5</code></p></td>
<td><p><code>0xfe</code> seguito dal numero come <code>uint32_t</code></p></td>
</tr>
<tr>
<td><p>≥ <code>0x100000000</code> &amp;&amp; ≤ <code>0xffffffffffffffff</code></p></td>
<td><p><code>9</code></p></td>
<td><p><code>0xff</code> seguito dal numero come <code>uint64_t</code></p></td>
</tr>
</tbody>
</table>
++++
****

Ogni input di una transazione deve contenere tre campi: un campo _outpoint_, un campo _script di input_ (preceduto dalla sua lunghezza) e un campo _sequence_. Esamineremo ciascuno di questi campi nelle sezioni seguenti. Alcuni input includono anche uno stack witness; tuttavia, essendo questo serializzato alla fine della transazione, lo ((("transactions", "inputs", "length of list", startref="transaction-input-length")))((("inputs", "length of list", startref="input-transaction-length")))esamineremo in seguito.

[[outpoints]]
==== Outpoint

Una transazione Bitcoin ((("transactions", "inputs", "outpoint field", id="transaction-input-outpoint")))((("inputs", "outpoint field", id="input-transaction-outpoint")))((("outpoint field (transaction inputs)", id="outpoint"))) rappresenta una richiesta inviata ai nodi completi affinché aggiornino il proprio database contenente le informazioni sulla proprietà dei bitcoin. Affinché Alice possa trasferire a Bob il controllo di alcuni dei suoi bitcoin, deve prima indicare ai nodi completi come individuare la transazione precedente tramite la quale ha ricevuto tali bitcoin. Poiché il controllo sui bitcoin è assegnato negli output delle transazioni, Alice _punta_ all'_output_ precedente utilizzando un campo denominato _outpoint_. Ogni input deve contenere un singolo outpoint.

L'outpoint contiene il TXID (Transaction ID) di 32 byte della transazione tramite la quale Alice ha ricevuto i bitcoin che ora intende spendere. Questo TXID è rappresentato secondo l'ordine dei byte interno di Bitcoin per gli hash (si veda <<internal_and_display_order>>).

Poiché una transazione può contenere molteplici output, Alice deve anche specificare quale particolare output di quella transazione intende utilizzare, indicandone il relativo _indice di output_ ((("output indexes"))). Gli indici di output sono interi senza segno di 4 byte a partire da zero.

Quando un nodo completo elabora un outpoint, utilizza le informazioni in esso contenute per tentare di individuare l'output a cui fa riferimento. I nodi completi devono cercare tale output solo nelle transazioni precedenti presenti nella blockchain. Ad esempio, la transazione di Alice è inclusa nel blocco 774.958. Un nodo completo che sta verificando la transazione di Alice cercherà l'output precedente, referenziato dall'outpoint, esclusivamente in quel blocco (774.958) e nei blocchi che lo precedono, mai nei blocchi successivi. All'interno dello stesso blocco 774.958, il nodo prenderà in considerazione solo le transazioni che precedono quella di Alice nell'ordine definito dalle foglie dell'albero di Merkle del blocco (si veda <<merkle_trees>>).

Una volta individuato l'output precedente, il nodo completo ne estrae diverse informazioni cruciali:

*   L'ammontare di bitcoin assegnato a quell'output precedente. L'intera somma verrà trasferita con questa transazione. Nella transazione d'esempio, il valore dell'output precedente era di 100.000 satoshi.

*   Le condizioni di autorizzazione associate a quell'output precedente. Si tratta delle condizioni che devono essere soddisfatte per poter spendere i bitcoin assegnati a tale output.

*   Per le transazioni confermate: l'altezza del blocco che le ha confermate e il Median Time Past (MTP) di quel blocco. Queste informazioni sono necessarie per i timelock relativi (descritti in <<relative_timelocks>>) e per gli output delle transazioni coinbase (descritti in <<coinbase_transactions>>).

*   La prova che l'output precedente esista nella blockchain (o sia noto come transazione non confermata) e che nessun'altra transazione lo abbia già speso. Una delle regole di consenso di Bitcoin, infatti, proibisce che un output venga speso più di una volta all'interno di una blockchain valida.

[[internal_and_display_order]]
.Ordini di Byte Interni e di Visualizzazione
****
Bitcoin utilizza l'output delle funzioni di hash, denominati _digest_, in vari modi. I digest forniscono identificatori univoci per blocchi e transazioni; vengono utilizzati per creare impegni crittografici (commitment) per indirizzi, blocchi, transazioni, firme e altro ancora; inoltre, i digest vengono elaborati iterativamente nella funzione di proof-of-work di Bitcoin. In alcuni casi, i digest degli hash vengono mostrati agli utenti in un ordine di byte ma utilizzati internamente in un ordine differente, generando confusione. Ad esempio, consideriamo il txid dell'output precedente dall'outpoint nella nostra transazione di esempio:

----
eb3ae38f27191aa5f3850dc9cad00492b88b72404f9da135698679268041c54a
----

Se proviamo a utilizzare questo txid per recuperare la transazione tramite Bitcoin Core, otteniamo un errore e dobbiamo invertire l'ordine dei byte:

----
$ bitcoin-cli getrawtransaction \
  eb3ae38f27191aa5f3850dc9cad00492b88b72404f9da135698679268041c54a
error code: -5
error message:
No such mempool or blockchain transaction. 
Use gettransaction for wallet transactions.

$ echo eb3ae38f27191aa5f3850dc9cad00492b88b72404f9da135698679268041c54a \
  | fold -w2 | tac | tr -d "\n"
4ac541802679866935a19d4f40728bb89204d0cac90d85f3a51a19278fe33aeb

$ bitcoin-cli getrawtransaction \
  4ac541802679866935a19d4f40728bb89204d0cac90d85f3a51a19278fe33aeb
02000000000101c25ae90c9f3d40cc1fc509ecfd54b06e35450702...
----

Questo comportamento anomalo è probabilmente una conseguenza non intenzionale di una [decisione di progettazione nel software Bitcoin originale](https://oreil.ly/01JH2). In pratica, ciò significa che gli sviluppatori di software Bitcoin devono ricordarsi di invertire l'ordine dei byte negli identificatori di transazioni e blocchi quando li mostrano agli utenti.

In questo libro, utilizziamo il termine _ordine di byte interno_ per i dati che appaiono all'interno di transazioni e blocchi, mentre utilizziamo _ordine di byte di visualizzazione_ per il formato mostrato agli utenti. Un'altra terminologia comune è _ordine di byte little-endian_ per la versione interna e _ordine di byte big-endian_ per la versione di visualizzazione.
****

==== Script di Input

Il campo script di input è un residuo del formato di transazione legacy. L'input della nostra transazione di esempio spende un output segwit nativo che non richiede alcun dato nello script di input, pertanto il prefisso di lunghezza per lo script di input è impostato a zero (0x00).

Per un esempio di script di input con prefisso di lunghezza che spende un output legacy, utilizziamo uno tratto da una transazione arbitraria nel blocco più recente al momento della stesura:

----
6b483045022100a6cc4e8cd0847951a71fad3bc9b14f24d44ba59d19094e0a8c
fa2580bb664b020220366060ea8203d766722ed0a02d1599b99d3c95b97dab8e
41d3e4d3fe33a5706201210369e03e2c91f0badec46c9c903d9e9edae67c167b
9ef9b550356ee791c9a40896
----

Il prefisso di lunghezza è un intero senza segno in formato compactSize che indica la lunghezza del campo script di input serializzato. In questo caso, si tratta di un singolo byte (0x6b) che indica che lo script di input è lungo 107 byte. Analizzeremo in dettaglio l'interpretazione e l'utilizzo degli script nel capitolo <<c_authorization_authentication>>.

[[sequence]]
==== Sequence

Gli ultimi quattro byte di un input costituiscono il suo numero di _sequence_. L'uso e il significato di questo campo sono cambiati nel corso del tempo.

[[original_tx_replacement]]
===== Sostituzione di transazioni basata su sequence (implementazione originale)

Il campo sequence era originariamente concepito per consentire la creazione di molteplici versioni della stessa transazione, dove le versioni successive sostituivano quelle precedenti come candidate alla conferma. Il numero di sequence teneva traccia della versione della transazione.

Ad esempio, immaginiamo che Alice e Bob vogliano scommettere su una partita a carte. Iniziano entrambi firmando una transazione che deposita del denaro in un output con uno script che richiede le firme di entrambi per essere speso, uno script _multisignature_ (o _multisig_ in breve). Questa è chiamata _transazione di setup_. Successivamente, creano una transazione che spende quell'output:

- La prima versione della transazione, con nSequence 0 (0x00000000), restituisce ad Alice e Bob il denaro che hanno inizialmente depositato. Questa è chiamata _transazione di rimborso_. Nessuno dei due trasmette la transazione di rimborso in questa fase. Ne hanno bisogno solo in caso di problemi.

- Alice vince il primo round del gioco di carte, quindi la seconda versione della transazione, con sequence 1, aumenta la quantità di denaro assegnata ad Alice e diminuisce la quota di Bob. Entrambi firmano la transazione aggiornata. Anche in questo caso, non hanno bisogno di trasmettere questa versione della transazione a meno che non si verifichi un problema.

- Bob vince il secondo round, quindi il sequence viene incrementato a 2, la quota di Alice viene diminuita e quella di Bob aumentata. Firmano nuovamente ma non trasmettono.

- Dopo molti altri round in cui il sequence viene incrementato, i fondi ridistribuiti e la transazione risultante firmata ma non trasmessa, decidono di finalizzare la transazione. Creando una transazione con il saldo finale dei fondi, impostano il sequence al suo valore massimo (0xffffffff), finalizzando la transazione. Trasmettono questa versione della transazione, che viene inoltrata attraverso la rete e infine confermata dai miner.

Possiamo osservare le regole di sostituzione basate su sequence in azione considerando scenari alternativi:

- Immaginiamo che Alice trasmetta la transazione finale, con un sequence di 0xffffffff, e poi Bob trasmetta una delle transazioni precedenti in cui il suo saldo era più alto. Poiché la versione della transazione di Bob ha un numero di sequence inferiore, i nodi completi che utilizzano il codice Bitcoin originale non la inoltreranno ai miner, e i miner che utilizzano anch'essi il codice originale non la includeranno nei blocchi.

- In un altro scenario, immaginiamo che Bob trasmetta una versione precedente della transazione pochi secondi prima che Alice trasmetta la versione finale. I nodi inoltreranno la versione di Bob e i miner tenteranno di includerla in un blocco, ma quando arriverà la versione di Alice con il suo numero di sequence più alto, i nodi la inoltreranno anch'essa e i miner che utilizzano il codice Bitcoin originale cercheranno di includere quest'ultima invece della versione di Bob. A meno che Bob non sia stato fortunato e un blocco sia stato scoperto prima dell'arrivo della versione di Alice, sarà la versione di Alice ad essere confermata.

Questo tipo di protocollo è ciò che oggi chiamiamo un _canale di pagamento_ (payment channel). Il creatore di Bitcoin, in un'email a lui attribuita, chiamò queste _transazioni ad alta frequenza_ e descrisse una serie di funzionalità aggiunte al protocollo per supportarle. Più avanti esamineremo diverse di queste altre funzionalità e scopriremo come le versioni moderne dei canali di pagamento vengano sempre più utilizzate in Bitcoin oggi.

I canali di pagamento basati esclusivamente sul sequence presentavano alcuni problemi. Il primo era che le regole per sostituire una transazione con sequence inferiore con una con sequence superiore erano solo una questione di policy del software. Non c'era alcun incentivo diretto per i miner a preferire una versione della transazione rispetto a un'altra. Il secondo problema era che la prima persona a inviare la propria transazione poteva essere fortunata e vederla confermata anche se non era la transazione con il sequence più alto. Un protocollo di sicurezza che fallisce una piccola percentuale di volte a causa della sfortuna non è un protocollo molto efficace.

Il terzo problema era la possibilità di sostituire una versione di una transazione con una diversa un numero illimitato di volte. Ogni sostituzione avrebbe consumato la larghezza di banda di tutti i nodi completi di inoltro nella rete. Ad esempio, al momento della stesura, ci sono circa 50.000 nodi completi di inoltro; un attaccante che creasse 1.000 transazioni sostitutive al minuto, ciascuna di 200 byte, utilizzerebbe circa 20 KB della propria larghezza di banda personale ma circa 10 GB di larghezza di banda della rete di nodi completi ogni minuto. A parte il costo della propria larghezza di banda di 20 KB/minuto e l'occasionale commissione quando una transazione venisse confermata, l'attaccante non dovrebbe sostenere alcun costo per l'enorme carico imposto agli operatori di nodi completi.

Per eliminare il rischio di questo attacco, il tipo originale di sostituzione delle transazioni basata su sequence è stato disabilitato in una versione iniziale del software Bitcoin. Per diversi anni, i nodi completi Bitcoin non avrebbero permesso che una transazione non confermata contenente un particolare input (come indicato dal suo outpoint) fosse sostituita da una transazione diversa contenente lo stesso input. Tuttavia, questa situazione non è durata per sempre.


[[sequence-bip125]]
===== Opt-in transaction replacement signaling

After the original sequence-based transaction replacement was disabled
due to the potential for abuse, a solution was proposed: programming
Bitcoin Core and other relaying full node software to allow a
transaction that paid a higher transaction fee rate to replace a
conflicting transaction that paid a lower fee rate.  This is called
_replace by fee_, or _RBF_ for short.  Some users and businesses
objected to adding support for transaction replacement back into Bitcoin
Core, so a compromise was reached that once again used the sequence
field in support of replacement.

As documented in BIP125, an unconfirmed transaction with any input that
has a sequence set to a value below 0xfffffffe (i.e., at least 2 below
the maximum value) signals to the network that its signer wants it to be
replaceable by a conflicting transaction paying a higher fee rate.
Bitcoin Core allowed those unconfirmed transactions to be replaced and
continued to disallow other transactions from being replaced.  This
allowed users and businesses that objected to replacement to simply
ignore unconfirmed transactions containing the BIP125 signal until they
became confirmed.

There's more to modern transaction replacement policies than fee rates
and sequence signals, which we'll see in <<rbf>>.

[[relative_timelocks]]
===== Sequence as a consensus-enforced relative timelock

In <<version>>, we learned that the BIP68 soft fork added
a new constraint to transactions with version numbers 2 or higher.  That
constraint applies to the sequence field.

Transaction inputs with sequence values less than 2^31^ are
interpreted as having a relative timelock. Such a transaction may only
be included in the blockchain once the previous output (referenced by the
outpoint) has aged by the relative timelock amount. For example, a
transaction with one input with a relative timelock of 30 blocks can
only be confirmed in a block with at least 29 blocks between it and the
block containing the output being spent on the same blockchain.
Since sequence is a per-input field, a transaction may contain any
number of timelocked inputs, all of which must have sufficiently aged
for the transaction to be valid. A disable flag allows a transaction to
include both inputs with a relative timelock (sequence < 2^31^) and
inputs without a relative timelock (sequence ≥ 2^31^).

The sequence value is specified in either blocks or seconds.
A type-flag
is used to differentiate between values counting blocks and values
counting time in seconds. The type-flag is set in the 23rd
least-significant bit (i.e., value 1<<22). If the type-flag is set, then
the sequence value is interpreted as a multiple of 512 seconds. If
the type-flag is not set, the sequence value is interpreted as a
number of blocks.


When interpreting sequence as a relative timelock, only the 16 least
significant bits are considered. Once the flags (bits 32 and 23) are
evaluated, the sequence value is usually "masked" with a 16-bit mask
(e.g., +sequence+ & 0x0000FFFF).  The multiple of 512 seconds is
roughly equal to the average amount of time between blocks, so the
maximum relative timelock in both blocks and seconds from 16 bits
(2^16^) is a bit more than one year.

<<bip_68_def_of_nseq>> shows the binary layout of the sequence value,
as defined by BIP68.

[[bip_68_def_of_nseq]]
.BIP68 definition of sequence encoding (Source: BIP68).
image::images/mbc3_0603.png["BIP68 definition of sequence encoding"]

Note that any transaction that sets a relative timelock using sequence
also sends the signal for opt-in replace by fee as described in
<<sequence-bip125>>.

=== Outputs

The outputs field of a transaction contains several fields related to
specific outputs.  Just as we did with the inputs field, we'll start by
looking at the specific bytes of the outputs field from the example
transaction where Alice pays Bob, displayed as
a map of those bytes in <<output-byte-map>>.

[[output-byte-map]]
.A byte map of the outputs field from Alice's transaction.
image::images/mbc3_0604.png["A byte map of the outputs field from Alice's transaction"]

==== Outputs Count

Identical to the start of the inputs section of a transaction, the outputs
field begins with a count indicating the number of outputs in this
transaction.  It's a compactSize integer and must be greater than zero.

The example transaction has two outputs.

==== Amount

The first field of a specific output is its _amount_, also called
"value" in Bitcoin Core.  This is an 8-byte signed integer indicating
the number of satoshis to transfer.  A satoshi is the smallest unit of
bitcoin that can be represented in an onchain Bitcoin transaction.
There are 100 million satoshis in a bitcoin.

Bitcoin's consensus rules allow an output to have a value as small as
zero and as large as 21 million bitcoins (2.1 quadrillion satoshis).

//TODO:describe early integer overflow problem

[[uneconomical_outputs]]
===== Uneconomical outputs and disallowed dust

Despite not having any value, a zero-value output can be spent under
the same rules as any other output.  However, spending an output (using
it as the input in a transaction) increases the size of a transaction,
which increases the amount of fee that needs to be paid.  If the value
of the output is less than the cost of the additional fee, then it doesn't
make economic sense to spend the output.  Such outputs are known as
_uneconomical outputs_.

A zero-value output is always an uneconomical output; it wouldn't
contribute any value to a transaction spending it even if the
transaction's fee rate was zero.  However, many other outputs with low
values can be uneconomical as well, even unintentionally.  For example,
at a typical fee rate on the network today, an output might add more
value to a transaction than it costs to spend--but tomorrow, fee rates
might rise and make the output uneconomical.

The need for full nodes to keep track of all UTXOs, as described in <<outpoints>>, means that every UTXO makes it
slightly harder to run a full node.  For UTXOs containing significant
value, there's an incentive to eventually spend them, so they aren't a
problem.  But there's no incentive for the person controlling an
uneconomical UTXO to ever spend it, potentially making it a perpetual
burden on operators of full nodes.  Because Bitcoin's decentralization
depends on many people being willing to run full nodes, several full
node implementations such as Bitcoin Core discourage the creation of
uneconomical outputs using policies that affect the relay and mining of
unconfirmed transactions.

[role="less_space pagebreak-before"]
The policies against relaying or mining transactions creating new
uneconomical outputs are called _dust_ policies, based on a metaphorical
comparison between outputs with very small values and particles with
very small size.  Bitcoin Core's dust policy is complicated and contains
several arbitrary numbers, so many programs we're aware of simply
assume outputs with less than 546 satoshis are dust and will not be
relayed or mined by default.  There are occasionally proposals to lower
dust limits, and counterproposals to raise them, so we encourage
developers using presigned transactions or multiparty protocols to
check whether the policy has changed since publication of this book.

[TIP]
====
Since Bitcoin's inception, every full node has needed to keep a copy of
every UTXO, but that might not always be
the case.  Several developers have been working on Utreexo, a project
that allows full nodes to store a commitment to the set of UTXOs rather
than the data itself.  A minimal commitment might be only a kilobyte or
two in size--compare that to the over five gigabytes Bitcoin Core stores
as of this writing.

However, Utreexo will still require some nodes to store all UTXO data,
especially nodes serving miners and other operations that need to
quickly validate new blocks.  That means uneconomical outputs can still
be a problem for full nodes even in a possible future where most nodes
use Utreexo.
====

Bitcoin Core's policy rules about dust do have one exception: output
scripts starting with +OP_RETURN+, called _data carrier outputs_,
can have a value of zero.  The +OP_RETURN+ opcode causes the script to
immediately fail no matter what comes after it, so these outputs can
never be spent.  That means full nodes don't need to keep track of them,
a feature Bitcoin Core takes advantage of to allow users to store small
amounts of arbitrary data in the blockchain without increasing the size
of its UTXO database.  Since the outputs are unspendable, they aren't
uneconomical--any satoshis assigned to them become
permanently unspendable--so allowing the amount to be zero ensures
satoshis aren't being destroyed.

==== Output Scripts

The output amount is followed by a compactSize integer indicating the
length of the _output script_, the script that contains the
conditions that will need to be fulfilled in order to spend the
bitcoins.  According to Bitcoin's
consensus rules, the minimum size of an output script is zero.

The consensus maximum allowed size of an output script varies depending on
when it's being checked.  There's no explicit limit on the size of an
output script in the output of a transaction, but a later transaction can
only spend a previous output with a script of 10,000 bytes or
smaller.  Implicitly, an output script can be almost as large as the
transaction containing it, and a transaction can be almost as large as
the block containing it.

[[anyone-can-spend]]
[TIP]
====
An output script with zero length can be spent by an input script containing
++OP_TRUE++.  Anyone can create that input script, which means anyone
can spend an empty output script.  There are an essentially unlimited
number of scripts that anyone can spend, and they are known to Bitcoin
protocol developers as _anyone can spends_.  Upgrades to Bitcoin's
script language often take an existing anyone-can-spend script and add
new constraints to it, making it only spendable under the new
conditions.  Application developers should never need to use an
anyone-can-spend script, but if you do, we highly recommend that you
loudly announce your plans to Bitcoin users and developers so that
future upgrades don't accidentally interfere with your system.
====

Bitcoin Core's policy for relaying and mining transactions effectively
limits output scripts to just a few templates, called _standard
transaction outputs_.  This was originally implemented after the
discovery of several early bugs in Bitcoin related to the Script
language and is retained in modern Bitcoin Core to support
anyone-can-spend upgrades and to encourage the best practice of placing
script conditions in P2SH redeem scripts, segwit v0 witness scripts, and
segwit v1 (taproot) leaf scripts.

We'll look at each of the current standard transaction templates and
learn how to parse scripts in <<c_authorization_authentication>>.

[[witness_structure]]
=== Witness Structure

In court,a witness is someone who testifies that they saw something
important happen.  Human witnesses aren't always reliable, so courts
have various processes for interrogating witnesses to (ideally) only
accept evidence from those who are reliable.

Imagine what a witness would look like for a math problem.  For example,
if the important problem was _x + 2 == 4_ and someone claimed they
witnessed the solution, what would we ask them?  We'd want a
mathematical proof that showed a value that could be summed with two to
equal four.  We could even omit the need for a person and just use the
proposed value for _x_ as our witness.  If we were told that the witness
was _two_, then we could fill in the equation, check that it was correct, and
decide that the important problem had been solved.

When spending bitcoins, the important problem we want to solve is
determining whether the spend was authorized by the person or people who
control those bitcoins.  The thousands of full nodes that enforce
Bitcoin's consensus rules can't interrogate human witnesses, but they can
accept _witnesses_ that consist entirely of data for solving math
problems.  For example, a witness of _2_ will allow spending bitcoins
protected by the following script:

----
2 OP_ADD 4 OP_EQUAL
----

Obviously, allowing your bitcoins to be spent by anyone who can solve a
simple equation wouldn't be secure.  As we'll see in <<c_signatures>>, an
unforgeable digital signature scheme uses an equation that can only be
solved by someone in possession of certain data they're able to
keep secret.  They're able to reference that secret data using a public
identifier.  That public identifier is called a _public key_ and a
solution to the equation is called a _signature_.

The following script contains a public key and an opcode that requires
a corresponding signature commit to the data in the spending transaction.  Like
the number _2_ in our simple example, the signature is our witness:

----
<public key> OP_CHECKSIG
----

Witnesses, the values used to solve the math problems that protect
bitcoins, need to be included in the transactions where they're used in
order for full nodes to verify them.  In the legacy transaction format
used for all early Bitcoin transactions, signatures and other data are
placed in the input script field.  However, when developers started to
implement contract protocols on Bitcoin, such as we saw in
<<original_tx_replacement>>, they discovered several significant
problems with placing witnesses in the input script field.

==== Circular Dependencies

Many contract protocols for Bitcoin involve a series of transactions
that are signed out of order.  For example, Alice and Bob want to
deposit funds into a script that can only be spent with signatures from
both of them, but they each also want to get their money back if the
other person becomes unresponsive.  A simple solution is to sign
transactions out of order:

- Tx~0~ pays money from Alice and money from Bob into an output with a
  script that requires signatures from both Alice and Bob to spend.

- Tx~1~ spends the previous output to two outputs, one refunding Alice
  her money and one refunding Bob his money (minus a small amount for
  transaction fees).

- If Alice and Bob sign Tx~1~ before they sign Tx~0~, then they're both
  guaranteed to be able to get a refund at any time.  The protocol
  doesn't require either of them to trust the other, making it a _trustless
  protocol_.

A problem with this construction in the legacy transaction format is
that every field, including the input script field that contains
signatures, is used to derive a [.keep-together]#transaction's# identifier (txid).  The
txid for Tx~0~ is part of the input's outpoint in Tx~1~.  That means
there's no way for Alice and Bob to construct Tx~1~ until both
signatures for Tx~0~ are known--but if they know the signatures for
Tx~0~, one of them can broadcast that transaction before signing the
refund transaction, eliminating the guarantee of a refund.  This is a
_circular dependency_.

==== Third-Party Transaction Malleability

A more complex series of transactions can sometimes eliminate a circular
dependency, but many protocols will then encounter a new concern: it's
often possible to solve the same script in different ways.  For example,
consider our simple script from <<witness_structure>>:

----
2 OP_ADD 4 OP_EQUAL
----

We can make this script pass by providing the value _2_ in an input script,
but there are several ways to put that value on the stack in Bitcoin.
Here are just a few:

----
OP_2
OP_PUSH1 0x02
OP_PUSH2 0x0002
OP_PUSH3 0x000002
...
OP_PUSHDATA1 0x0102
OP_PUSHDATA1 0x020002
...
OP_PUSHDATA2 0x000102
OP_PUSHDATA2 0x00020002
...
OP_PUSHDATA4 0x0000000102
OP_PUSHDATA4 0x000000020002
...
----

Each alternative encoding of the number _2_ in an input script will produce
a slightly different transaction with a completely different txid.  Each
different version of the transaction spends the same inputs (outpoints)
as every other version of the transaction, making them all _conflict_
with each other.  Only one version of a set of conflicting transactions
can be contained within a valid blockchain.

Imagine Alice creates one version of the transaction with +OP_2+ in the
input script and an output that pays Bob.  Bob then immediately spends that
output to Carol.  Anyone on the network can replace +OP_2+ with
+OP_PUSH1 0x02+, creating a conflict with Alice's original version.  If
that conflicting transaction is confirmed, then there's no way to
include Alice's original version in the same blockchain, which means
there's no way for Bob's transaction to spend its output.
Bob's payment to Carol has been made invalid even though neither Alice,
Bob, nor Carol did anything wrong.  Someone not involved in the
transaction (a third party) was able to change (mutate) Alice's
transaction, a problem called _unwanted third-party transaction
malleability_.

[TIP]
====
There are cases when people want their transactions to be malleable and
Bitcoin provides several features to support that, most notably the
signature hashes (sighash) we'll learn about in <<sighash_types>>.  For
example, Alice can use a sighash to allow Bob to help her pay some
transaction fees.  This mutates Alice's transaction but only in a way
that Alice wants.  For that reason, we will occasionally prefix the
word _unwanted_ to the term _transaction malleability_.  Even when we
and other Bitcoin technical writers use the shorter term, we're almost
certainly talking about the unwanted variant of malleability.
====

==== Second-Party Transaction Malleability

When the legacy transaction format was the only transaction format,
developers worked on proposals to minimize third-party malleability,
such as BIP62.  However, even if they were able to entirely eliminate
third-party malleability, users of contract protocols faced another problem:
if they required a signature from someone else involved in the protocol,
that person could generate alternative signatures and change the txid.

For example, Alice and Bob have deposited their money into a script
requiring a signature from both of them to spend.  They've also created
a refund transaction that allows each of them to get their money back at
any time.  Alice decides she wants to spend just some of the
money, so she cooperates with Bob to create a chain of transactions:

- Tx~0~ includes signatures from both Alice and Bob, spending its
  bitcoins to two outputs.  The first output spends some of Alice's
  money; the second output returns the remainder of the bitcoins back to
  the script requiring Alice and [.keep-together]#Bob's signatures.#  Before signing this
  transaction, they create a new refund transaction, Tx~1~.

- Tx~1~ spends the second output of Tx~0~ to two new outputs, one to
  Alice for her share of the joint funds, and one to Bob for his share.
  Alice and Bob both sign this transaction before they sign Tx~0~.

There's no circular dependency here and, if we ignore third-party
transaction malleability, this looks like it should provide us with a
trustless protocol.  However, it's a property of Bitcoin signatures that
the signer has to choose a large random number when creating their
signature.  Choosing a different random number will produce a different
signature even if everything being signed stays the same.  It's sort of
like how, if you provide a handwritten signature for two copies of the
same contract, each of those physical signatures will look slightly
different.

This mutability of signatures means that, if Alice tries to broadcast
Tx~0~ (which contains Bob's signature), Bob can generate an alternative
signature to create a conflicting transaction with a different txid.  If
Bob's alternative version of Tx~0~ gets confirmed, then Alice can't use
the presigned version of Tx~1~ to claim her refund.  This type of
mutation is called _unwanted second-party transaction malleability_.

[[segwit]]
==== Segregated Witness

As early as https://oreil.ly/---bp[2011],
protocol developers knew how to solve the problems of circular
dependence, third-party malleability, and second-party malleability.  The
idea was to avoid including the input script in the calculation that
produces a transaction's txid.  Recall that an abstract name for the data
held by an input script is a _witness_.  The idea of separating the rest of
the data in a transaction from its witness for the purpose of generating
a txid is called _segregated witness_ (segwit).

The obvious method for implementing segwit requires a
change to Bitcoin's consensus rules that would not be compatible with
older full nodes, also called
a _hard fork_.  Hard forks come with a lot of challenges, as we'll
discuss further in <<hard_forks>>.

An alternative approach to segwit was described in late 2015.  This
would use a backward-compatible change to the consensus rules, called a
_soft fork_.  Backward compatible means that full nodes implementing
the change must not accept any blocks that full nodes without the change
would consider invalid.  As long as they obey that rule, newer full
nodes can reject blocks that older full nodes would accept, giving them
the ability to enforce new consensus rules (but only if the newer full
nodes represent the economic consensus among Bitcoin users--we'll
explore the details of upgrading Bitcoin's consensus rules in
<<mining>>).

The soft fork segwit approach is based on anyone-can-spend
output scripts.  A script that starts with any of the numbers 0 to 16
and followed by 2 to 40 bytes of data is defined as a segwit
output script template.  The number indicates its version (e.g., 0 is
segwit version 0, or _segwit v0_).  The data is called a _witness
program_.  It's also possible to wrap the segwit template in a P2SH
commitment, but we won't deal with that in this chapter.

From the perspective of old nodes, these output script templates can be
spent with an empty input script.  From the perspective of a new node that
is aware of the new segwit rules, any payment to a segwit output script
template must only be spent with an empty input script.  Notice the
difference here: old nodes _allow_ an empty input script; new nodes
_require_ an empty input script.

[role="less_space pagebreak-before"]
An empty input script keeps witnesses from affecting the txid, eliminating
circular dependencies, third-party transaction malleability, and
second-party transaction malleability.  But, with no ability to put
data in an input script, users of segwit output script templates need a
new field.  That field is called the _witness structure_.

The introduction of witness programs and the witness structure complicates Bitcoin,
but it follows an existing trend of increasing abstraction.  Recall from
<<ch04_keys_addresses>> that the original Bitcoin whitepaper describes a system
where bitcoins were received to public keys (pubkeys) and spent with
signatures (sigs).  The public key defined who was _authorized_ to spend
the bitcoins (whoever controlled the corresponding private key) and the
signature provided _authentication_ that the spending transaction came
from someone who controlled the private key.  To make that system more
flexible, the initial release of Bitcoin introduced scripts that allow
bitcoins to be received to output scripts and spent with input scripts.
Later experience with contract protocols inspired allowing bitcoins to
be received to witness programs and spent with the witness structure. The terms and fields used in different versions of Bitcoin are shown in <<terms_used_authorization_authentication>>.

++++
<table id="terms_used_authorization_authentication">
<caption>Terms used for authorization and authentication data in different parts of Bitcoin</caption>
<thead>
<tr>
<th/>
<th><p>Authorization</p></th>
<th class="right"><p>Authentication</p></th>
</tr></thead>
<tbody>
<tr>
<td class="fakeheader"><p><strong>Whitepaper</strong></p></td>
<td><p>Public key</p></td>
<td class="right"><p>Signature</p></td>
</tr>
<tr>
<td  class="fakeheader"><p><strong>Original (Legacy)</strong></p></td>
<td><p>Output script</p></td>
<td class="right"><p>Input script</p></td>
</tr>
<tr>
<td  class="fakeheader"><p><strong>Segwit</strong></p></td>
<td><p>Witness program</p></td>
<td class="right"><p>Witness structure</p></td>
</tr>
</tbody>
</table>
++++

==== Witness Structure Serialization

Similar to the inputs and outputs fields, the witness structure contains
other fields, so we'll start with a map of those bytes from
Alice's transaction in <<alice_tx_witness_map>>.

[[alice_tx_witness_map]]
.A byte map of the witness structure from Alice's transaction.
image::images/mbc3_0605.png["A byte map of the witness from Alice's transaction"]

Unlike the inputs and outputs fields, the overall witness structure doesn't
start with any indication of the total number of witness stacks it contains.
Instead, this is implied by the inputs field--there's one witness
stack for every input in a transaction.

The witness structure for a particular input does start with a count of the
number of elements they contain.  Those elements are called _witness
items_.  We'll explore them in detail in
<<c_authorization_authentication>>, but for now we need to know that
each witness item is prefixed by a compactSize integer indicating its
size.

Legacy inputs don't contain any witness items, so their witness stack
consists entirely of a count of zero (0x00).

Alice's transaction contains one input and one witness item.

[[lock_time]]
=== Lock Time

The final field in a serialized transaction is its lock time.  This
field was part of Bitcoin's original serialization format, but it was
initially only enforced by Bitcoin's policy for choosing which
transactions to mine.  Bitcoin's earliest known soft fork added a rule
that, starting at block height 31,000, forbid the inclusion of a
transaction in a block unless it satisfies one of the following rules:

- The transaction indicates that it should be eligible for inclusion in
  any block by setting its lock time to 0.

- The transaction indicates that it wants to restrict which blocks it
  can be included in by setting its lock time to a value less than
  500,000,000.  In this case, the transaction can only be included in a
  block that has a height equal to the lock time or higher.  For
  example, a transaction with a lock time of 123,456 can be included in
  block 123,456 or any later block.

- The transaction indicates that it wants to restrict when it can be
  included in the blockchain by setting its lock time to a value of
  500,000,000 or greater.  In this case, the field is parsed as epoch
  time (the number of seconds since 1970-01-01T00:00 UTC) and the
  transaction can only be included in a block with a _median time past_
  (MTP) greater than the lock time.  MTP is normally about an hour or
  two behind the current time.  The rules for MTP are described in
  <<mtp>>.

[[coinbase_transactions]]
=== Coinbase Transactions

The first transaction in each block is a special case.  Most older
documentation calls this a _generation transaction_, but most newer
documentation calls it a _coinbase transaction_ (not to be confused with
transactions created by the company named "Coinbase").

Coinbase transactions are created by the miner of the block that
includes them and gives the miner the option to claim any fees paid by
transactions in that block.  Additionally, up until block 6,720,000,
miners are allowed to claim a subsidy consisting of bitcoins that have
never previously been circulated, called the _block subsidy_.  The total
amount a miner can claim for a block--the combination of fees and
subsidy--is called the _block reward_.

Some of the special rules for coinbase transactions include:

- They may only have one input.

- The single input must have an outpoint with a null txid (consisting entirely
  of zeros) and a maximal output index (0xffffffff).  This prevents the
  coinbase transaction from referencing a previous transaction output,
  which would (at the very least) be confusing given that the coinbase
  transaction pays out fees and subsidy.

- The field that would contain an input script in a normal transaction is
  called a _coinbase_.  It's this field that gives the coinbase
  transaction its name.  The coinbase field must be at least two bytes
  and not longer than 100 bytes.  This script is not executed but legacy
  transaction limits on the number of signature-checking operations
  (sigops) do apply to it, so any arbitrary data placed in it should be
  prefixed by a data-pushing opcode.  Since a 2013 soft fork defined in
  BIP34, the first few bytes of this field must follow additional rules
  we'll describe in <<duplicate_transactions>>.

- The sum of the outputs must not exceed the value of the fees collected
  from all the transactions in that block plus the subsidy.  The subsidy
  started at 50 BTC per block and halves every 210,000 blocks
  (approximately every four years).  Subsidy values are rounded down to the
  nearest satoshi.

- Since the 2017 segwit soft fork documented in BIP141, any block that contains
  a transaction spending a segwit output must contain an output to the
  coinbase transaction that commits to all of the transactions in the
  block (including their witnesses).  We'll explore this commitment in
  <<mining>>.

A coinbase transaction can have any other outputs that would be valid in
a normal transaction.  However, a transaction spending one of those
outputs cannot be included in any block until after the coinbase
transaction has received 100 confirmations.  This is called the
_maturity rule_, and coinbase transaction outputs that don't yet have
100 confirmations are called _immature_.

//TODO:stretch goal to describe the reason for the maturity rule and,
//by extension the reason for no expiring timelocks

Most Bitcoin software doesn't need to deal with coinbase transactions,
but their special nature does mean they can occasionally be the cause of
unusual problems in software that's not designed to expect them.

// Useful content deleted
// - no input amount in transactions
// - no balances in transactions
//   - UTXO model theory?
// Coin selection
// Change
// Inability for lightweight clients to get old UTXOs

=== Weight and Vbytes

Each Bitcoin block is limited in the amount of transaction data it can
contain, so most Bitcoin software needs to be able to measure the
transactions it creates or processes.  The modern unit of measurement
for Bitcoin is called _weight_.  An alternative version of weight is
_vbytes_, where four units of weight equal one vbyte, providing an easy
comparison to the original _byte_ measurement unit used in legacy
Bitcoin blocks.

Blocks are limited to 4 million weight.  The block header takes up 240
weight.  An additional field, the transaction count, uses either 4 or
12 weight.  All of the remaining weight may be used for transaction
data.

To calculate the weight of a particular field in a transaction, the size
of that serialized field in bytes is multiplied by a factor.  To
calculate the weight of a transaction, sum together the weights of all
of its fields.  The factors for each of the fields in a transaction are
shown in <<weight_factors>>.  To provide an example, we also calculate
the weight of each field in this chapter's example transaction from
Alice to Bob.

The factors, and the fields to which they are applied, were chosen to
reduce the weight used when spending a UTXO.  This helps discourage the
creation of uneconomical outputs as described in
<<uneconomical_outputs>>.

++++
<table id="weight_factors">
<caption>Weight factors for all fields in a Bitcoin transaction</caption>
<thead>
<tr>
<th><p>Field</p></th>
<th><p>Factor</p></th>
<th><p>Weight in Alice’s Tx</p></th>
</tr> </thead>
<tbody>
<tr>
<td><p>Version</p></td>
<td><p>4</p></td>
<td><p>16</p></td>
</tr>
<tr>
<td><p>Marker &amp; Flag</p></td>
<td><p>1</p></td>
<td><p>2</p></td>
</tr>
<tr>
<td><p>Inputs Count</p></td>
<td><p>4</p></td>
<td><p>4</p></td>
</tr>
<tr>
<td><p>Outpoint</p></td>
<td><p>4</p></td>
<td><p>144</p></td>
</tr>
<tr>
<td><p>Input script</p></td>
<td><p>4</p></td>
<td><p>4</p></td>
</tr>
<tr>
<td><p>Sequence</p></td>
<td><p>4</p></td>
<td><p>16</p></td>
</tr>
<tr>
<td><p>Outputs Count</p></td>
<td><p>4</p></td>
<td><p>4</p></td>
</tr>
<tr>
<td><p>Amount</p></td>
<td><p>4</p></td>
<td><p>64 (2 outputs)</p></td>
</tr>
<tr>
<td><p>Output script</p></td>
<td><p>4</p></td>
<td><p>232 (2 outputs with different scripts)</p></td>
</tr>
<tr>
<td><p>Witness Count</p></td>
<td><p>1</p></td>
<td><p>1</p></td>
</tr>
<tr>
<td><p>Witness items</p></td>
<td><p>1</p></td>
<td><p>66</p></td>
</tr>
<tr>
<td><p>Lock time</p></td>
<td><p>4</p></td>
<td><p>16</p></td>
</tr>
<tr>
<td><p><strong>Total</strong></p></td>
<td><p><em>N/A</em></p></td>
<td><p><strong>569</strong></p></td>
</tr>
</tbody>
</table>
++++

[role="less_space pagebreak-before"]
We can verify our weight calculation by getting the total for Alice's
transaction from Bitcoin Core:

----
$ bitcoin-cli getrawtransaction 466200308696215bbc949d5141a49a41\
38ecdfdfaa2a8029c1f9bcecd1f96177 2 | jq .weight
569
----

Alice's transaction from <<alice_tx_serialized_reprint>> at the beginning of
this chapter is shown represented in weight units in
<<alice_tx_weight_map>>.  You can see the factor at work by comparing
the difference in size between the various fields in the two images.

[[alice_tx_weight_map]]
.A byte map of Alice's transaction.
image::images/mbc3_0606.png["A weight map of Alice's transaction"]

[[legacy_serialization]]
=== Legacy Serialization

The serialization format described in this chapter is used for the
majority of new Bitcoin transactions as of the writing of this book, but
an older serialization format is still used for many transactions.  That
older format, called _legacy serialization_, must be used on the Bitcoin
P2P network for any transaction with an empty witness structure (which is only
valid if the transaction doesn't spend any witness programs).

Legacy serialization does not include the marker, flag, and witness structure
fields.

++++
<p class="fix_tracking2">
In this chapter, we looked at each of the fields in a transaction and
discovered how they communicate to full nodes the details about the
bitcoins to be transferred between users.  We only briefly looked at the
output script, input script, and witness structure that allow specifying and
satisfying conditions that restrict who can spend what bitcoins.
Understanding how to construct and use these conditions is essential to
ensuring that only Alice can spend her bitcoins, so they will be the
subject of the next chapter.</p>
++++

//TODO:text long section or full chapter about psbts